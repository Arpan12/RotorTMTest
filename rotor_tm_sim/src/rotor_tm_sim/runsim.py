#!/usr/bin/python3
#from MpcControl import *
import sys
import numpy as np
from pathlib import Path
import os
from dataclasses import dataclass
from rotor_tm_utils import read_params
import inspect
import scipy
import simulation_base
import rospkg

if __name__ == '__main__':
  # get an instance of RosPack with the default search paths
  rospack = rospkg.RosPack()
  # get the file path for rotor_tm_config
  path = rospack.get_path('rotor_tm_config')
  situation = sys.argv[1]

  if situation == "multi":
    ###############     3 snapdragon flights with triangular payload using cable mechanisms     ##################
    uav_params_path = path + '/config/uav_params/snapdragonfly.yaml'
    payload_params_path = path + '/config/load_params/triangular_payload.yaml'
    mechanism_params_path = path + '/config/attach_mechanism/3_robots_cable_mechanism.yaml'
    payload_control_gain_path = path + '/config/control_params/triangular_payload_cooperative_cable_gains.yaml'
    uav_control_gain_path = path + '/config/control_params/dragonfly_control_gains.yaml'
  elif situation == "ptmass":
    ###############     1 snapdragon flights with point-mass payload using cable mechanisms     ##################
    uav_params_path = path + '/config/uav_params/snapdragonfly.yaml'
    payload_params_path = path + '/config/load_params/pointmass_payload.yaml'
    mechanism_params_path = path + '/config/attach_mechanism/ptmass_cable_mechanism.yaml'
    payload_control_gain_path = path + '/config/control_params/pointmass_cable_gains.yaml'
    uav_control_gain_path = path + '/config/control_params/dragonfly_control_gains.yaml'
  elif situation == "rigid":
    #############     3 snapdragon flights with triangular payload using rigid link mechanisms     ################
    uav_params_path = path + '/config/uav_params/snapdragonfly.yaml'
    payload_params_path = path + '/config/load_params/triangular_payload.yaml'
    mechanism_params_path = path + '/config/attach_mechanism/rigid_links_mechanism.yaml'
    payload_control_gain_path = path + '/config/control_params/triangular_payload_cooperative_rigidlink_gains.yaml'
    uav_control_gain_path = path + '/config/control_params/dragonfly_control_gains.yaml'



  read_params_funcs = read_params.read_params()
  pl_params, quad_params = read_params_funcs.system_setup(payload_params_path,uav_params_path,mechanism_params_path,payload_control_gain_path, uav_control_gain_path)
  
  rotortm_simulation_base = simulation_base.simulation_base(pl_params,quad_params)
    
  '''
    def cooperative_hybrid_test_trajectory(start = None,loadstart = None,loadstop = None,vis = None,trajhandle = None,pl_params = None,quad_params = None): 
    # TEST_TRAJECTORY simulates the robot from START to STOP following a PATH
    # that's been planned for MAP.
    # start - a 3d vector or a cell contains multiple 3d vectors
    # stop  - a 3d vector or a cell contains multiple 3d vectors
    # map   - map generated by your load_map
    # path  - n x 3 matrix path planned by your dijkstra algorithm
    # vis   - true for displaying visualization
        
        #pl_params = pt1

    payload();
        nquad = pl_params.nquad
        # ros initialization
        worldframe = 'simulator'
        payloadframe = 'payload'
        # tftree = rostf;
        
        ## ROS Visualizaton Setup
        cable_pub = rospy.Publisher('/cable/marker','visualization_msgs/Marker','DataFormat','struct')
        cable_marker_scale = 0.01 * np.ones((3,3))
        cable_marker_color = np.array([1.0,0.5,0.5,0.5])
        cable_marker_msg = init_marker_msg(cable_pub,5,0,worldframe,cable_marker_scale,cable_marker_color)
        for i in np.arange(1,nquad+1).reshape(-1):
            robot_marker_pub[i] = rospy.Publisher('/quadrotor' + num2str(i) + '/marker','visualization_msgs/Marker','DataFormat','struct')
            quadrotor_marker_scale = 0.5 * np.ones((3,3))
            quadrotor_marker_color = np.array([1.0,0.0,0.0,1.0])
            quadrotor_mesh = quad_params.mesh_path
            quadrotor_marker_msg[i] = init_marker_msg(robot_marker_pub[i],10,0,worldframe,quadrotor_marker_scale,quadrotor_marker_color,quadrotor_mesh)
        
        pl_odom_pub = rospy.Publisher('/payload/marker','visualization_msgs/Marker','DataFormat','struct')
        payload_marker_scale = np.ones((3,3))
        payload_marker_color = np.array([1.0,0.745,0.812,0.941])
        system_pub = rospy.Publisher('/system/marker','visualization_msgs/MarkerArray','DataFormat','struct')
        system_marker = rosmessage(system_pub)
        #Controller and trajectory generator handles
        if nquad == 1:
            controlhandle = single_payload_geometric_controller
            dynamicshandle = lambda t = None,s = None,pl_params = None: hybrid_ptmass_pl_transportationEOM(t,s,controlhandle,trajhandle,quad_params,pl_params)
            payload_marker_scale = np.ones((3,3)) * 0.1
            payload_marker_msg = init_marker_msg(pl_odom_pub,2,0,worldframe,payload_marker_scale,payload_marker_color)
        else:
            controlhandle = cooperative_suspended_payload_controller
            dynamicshandle = lambda t = None,s = None,pl_params = None: hybrid_cooperative_rigidbody_pl_transportationEOM(t,s,nquad,controlhandle,trajhandle,quad_params,pl_params)
            payload_mesh = pl_params.mesh_path
            payload_marker_msg = init_marker_msg(pl_odom_pub,10,0,worldframe,payload_marker_scale,payload_marker_color,payload_mesh)
        
        path_pub = rospy.Publisher('/payload/path','visualization_msgs/Marker','DataFormat','struct')
        path_scale = 0.01 * np.ones((3,3))
        path_color = np.array([1.0,1.0,0.0,0.0])
        path_msg = init_marker_msg(path_pub,4,0,worldframe,path_scale,path_color)
        des_path_pub = rospy.Publisher('/payload/des_path','visualization_msgs/Marker','DataFormat','struct')
        des_path_scale = 0.01 * np.ones((3,3))
        des_path_color = np.array([1.0,0.341,0.0235,0.549])
        des_path_msg = init_marker_msg(des_path_pub,4,0,worldframe,des_path_scale,des_path_color)
        # Make cell
        if not iscell(start) :
            start = np.array([start])
        
        # Make column vector
        for qn in np.arange(1,nquad+1).reshape(-1):
            start[qn] = start[qn]
        
        ## **************************** FIGURES *****************************
    # Environment figure
        if len(varargin) < 5:
            vis = True
        
        print('Initializing figures...\\n' % ())
        if vis:
            #h_fig = figure('Name', 'Environment');
            pass
        else:
            #h_fig = figure('Name', 'Environment', 'Visible', 'Off');
            pass
        
        ## ************1
    2
    3*********** INITIAL CONDITIONS ***********************
        print('Setting initial conditions...\\n' % ())
        # Maximum time that the quadrotor is allowed to fly
        time_tol = 60
        
        starttime = 0
        
        tstep = 0.01
        
        cstep = 0.05
        
        nstep = cstep / tstep
        time = starttime
        
        max_iter = time_tol / cstep
        
        pl0 = np.array([[loadstart(np.arange(1,3+1))],[0],[0],[0],[loadstart(np.arange(4,7+1))],[0],[0],[0]])
        x = pl0
        xtraj[0] = []
        ttraj[0] = []
        xtrajdes[0] = []
        for qn in np.arange(1,nquad+1).reshape(-1):
            # Get start and stop position
            attach = pl_params.rho_vec_list(:,qn)
            cable_len = pl_params.cable_length(qn)
            x0[qn] = init_state(start[qn],0)
            cable[qn] = init_cable_state(start[qn],pl0,attach,cable_len)
            xtrajdes[qn + 1] = []
            xtraj[qn + 1] = []
            ttraj[qn + 1] = []
            x = np.array([[x],[x0[qn]]])
        
        # Maximum position error of the quadrotor at goal
        pos_tol = 0.05
        
        # Maximum speed of the quadrotor at goal
        vel_tol = 0.05
        
        # state vector x (13 + 7*nquad + 6*nquad) x 1:
    # x     - [xL, yL, zL, xLd, yLd, zLd,
    #          [xL, yL, zL, xLd, yLd, zLd, qw, qx, qy, qz, pQuad, qQuad, rQuad]_i, i = 1,...,nquad
        quad_state = x0
        pl_dim_num = 13
        
        quad_dim_num = 7
        cable_dim_num = 6
        global cable_is_slack
        global sim_start
        sim_start = False
        cable_is_slack = not istaut(x(np.arange(1,3+1)) + np.transpose(QuatToRot(x(np.arange(7,10+1)))) * pl_params.rho_vec_list,x(13 * np.array([np.arange(1,nquad+1)]) + np.array([[1],[2],[3]])),pl_params.cable_length) 
        ## ************************* RUN SIMULATION *************************
        print('Simulation Running....\\n' % ())
        for iter in np.arange(1,max_iter+1).reshape(-1):
            timeint = np.arange(time,time + cstep+tstep,tstep)
            tic
            # The simulation must first run on the quadrotors
    # Then the simulation simulates the dynamics of the payload
    # If this is the first iteration in the simulation,
    # initialize the plots of the quads
            # The integration stops when the distance between robot and payload
    # equals to the cable length
            inelastic_collision_flag = check_inelastic_collision_idx(x,pl_params)
            while np.any(inelastic_collision_flag):

                print('collide!\n' % ())
                before_collide_inelastic_collision_flag = inelastic_collision_flag
                x = rigidbody_quad_inelastic_cable_collision(x,pl_params,quad_params,inelastic_collision_flag)
                print('after collide!\n' % ())
                after_collide_inelastic_collision_flag = check_inelastic_collision_idx(x,pl_params)
                if np.any((after_collide_inelastic_collision_flag - before_collide_inelastic_collision_flag) > 0):
                    inelastic_collision_flag = np.logical_or(after_collide_inelastic_collision_flag,before_collide_inelastic_collision_flag)
                else:
                    inelastic_collision_flag = after_collide_inelastic_collision_flag

            # State Integration
            slack_condition = cable_is_slack
            option = odeset('Events',lambda t = None,x = None: cooperativeGuard(t,x,pl_params,slack_condition))
            tsave,xsave,fsave = ode45(lambda t = None,s = None: dynamicshandle(t,s,pl_params),timeint,x,option)
            x = np.transpose(xsave(end(),:))
            # Check if the cable is slack
            cable_is_slack = not istaut(x(np.arange(1,3+1)) + np.transpose(QuatToRot(x(np.arange(7,10+1)))) * pl_params.rho_vec_list,x(13 * np.array([np.arange(1,nquad+1)]) + np.array([[1],[2],[3]])),pl_params.cable_length) 
            # Save to traj
            for qn in np.arange(1,nquad + 1+1).reshape(-1):
                xtraj[qn] = np.array([xtraj[qn],np.transpose(xsave(np.arange(1,end() - 1+1),np.arange(13 * qn - 12,13 * qn+1)))])
                ttraj[qn] = np.array([ttraj[qn],np.transpose(tsave(np.arange(1,end() - 1+1)))])
                for i in np.arange(1,len(tsave) - 1+1).reshape(-1):
                    desired_state = trajhandle(tsave(i),[])
                    xtrajdes[qn] = np.array([xtrajdes[qn],np.array([[desired_state.pos_des],[desired_state.vel_des],[np.transpose(desired_state.quat_des)],[np.transpose(desired_state.omega_des)]])])
            # Update payload state for visualization
            payload_state = x(np.arange(1,pl_dim_num+1))
            payload_rot = np.transpose(QuatToRot(payload_state(np.arange(7,10+1))))
            # Update quad state and cable state for visualization
            quad_state[0] = x(np.arange(pl_dim_num + 1,end()+1))
            cable_point_list = []
            for qn in np.arange(1,nquad+1).reshape(-1):
                quad_and_cable_state = x(np.arange(pl_dim_num + (quad_dim_num + cable_dim_num) * (qn - 1) + 1,pl_dim_num + (quad_dim_num + cable_dim_num) * qn+1))
                quad_state[qn][np.arange[7,13+1]] = quad_and_cable_state(np.arange(7,13+1))
                attach_qn = payload_state(np.arange(1,3+1)) + payload_rot * pl_params.rho_vec_list(:,qn)
                quad_state[qn][np.arange[1,3+1]] = quad_and_cable_state(np.arange(1,3+1))
                quad_state[qn][np.arange[4,6+1]] = payload_state(np.arange(4,6+1)) + payload_rot * cross(payload_state(np.arange(11,13+1)),pl_params.rho_vec_list(:,qn)) - pl_params.cable_length(qn) * quad_and_cable_state(np.arange(quad_dim_num + 4,end()+1))
                cable_point_list = np.array([cable_point_list,attach_qn,quad_and_cable_state(np.arange(1,3+1))])
            path_msg.points(iter).x = payload_state(1)
            path_msg.points(iter).y = payload_state(2)
            path_msg.points(iter).z = payload_state(3)
            path_time = rostime('now')
            path_msg.header.stamp.sec = uint32(path_time.Sec)
            path_msg.header.stamp.nsec = uint32(path_time.Nsec)
            send(path_pub,path_msg)
            des_path_msg.points(iter).x = desired_state.pos_des(1)
            des_path_msg.points(iter).y = desired_state.pos_des(2)
            des_path_msg.points(iter).z = desired_state.pos_des(3)
            des_path_msg.header.stamp.sec = uint32(path_time.Sec)
            des_path_msg.header.stamp.nsec = uint32(path_time.Nsec)
            send(des_path_pub,des_path_msg)
            # Update quadrotor visualization
            for qn in np.arange(1,nquad+1).reshape(-1):
                system_marker.markers[qn] = update_marker_msg(quadrotor_marker_msg[qn],quad_state[qn](np.arange(1,3+1)),RotToQuat(np.transpose(QuatToRot(quad_state[qn](np.arange(7,10+1))))),qn)
            # Update cable visualization
            system_marker.markers[nquad + 1] = update_line_list_msg(cable_marker_msg,cable_point_list,nquad + 1)
            # Update payload visualization
            system_marker.markers[nquad + 2] = update_marker_msg(payload_marker_msg,payload_state(np.arange(1,3+1)),RotToQuat(payload_rot),0)
            send(system_pub,system_marker)
            # Update simulation time
            time = time + tsave(end()) - tsave(1)
            t = toc
            # Pause to make real-time
            if (t < cstep):
                #fprintf('t is smaller than cstep\n')
                pause(cstep - t)
            # TODO: Check termination criteria
            terminate_cond = terminate_check(payload_state,time,loadstop,pos_tol,vel_tol,time_tol)
            if terminate_cond:
                break
        
        print('Simulation Finished....\\n' % ())
        ## ************************* POST PROCESSING *************************
    # Truncate xtraj and ttraj
    # for qn = 1:nquad+1
    #     xtraj{qn} = xtraj{qn}(1:iter*nstep,:);
    #     ttraj{qn} = ttraj{qn}(1:iter*nstep);
    # end
        
        # Plot position for the payload
        
        #plot_state(load_pos_plot, LP.state_des_hist(1:3,:), LP.time_hist, 'pos', 'des');
        
        return xtraj,xtrajdes,ttraj,terminate_cond
        
        return xtraj,xtrajdes,ttraj,terminate_cond
    '''

  
   
    
