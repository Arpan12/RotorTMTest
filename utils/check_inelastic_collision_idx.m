function collision_condition = check_inelastic_collision_idx(x,pl_params)
% TEST_TRAJECTORY simulates the robot from START to STOP following a PATH
% that's been planned for MAP.
% start - a 3d vector or a cell contains multiple 3d vectors
% stop  - a 3d vector or a cell contains multiple 3d vectors
% map   - map generated by your load_map
% path  - n x 3 matrix path planned by your dijkstra algorithm
% vis   - true for displaying visualization

%% State Assignment
nquad = pl_params.nquad;
rho_vec_list = pl_params.rho_vec_list;
pl_pos = x(1:3);
pl_vel = x(4:6);
pl_rot = QuatToRot(x(7:10))';
attach_pos = pl_pos + pl_rot * rho_vec_list;
attach_vel = pl_vel + pl_rot * vec2asym(x(11:13)) * rho_vec_list;
robot_pos  = x(13*[1:nquad] + [1;2;3]);
robot_vel  = x(13*[1:nquad] + [4;5;6]);
xi = (attach_pos - robot_pos)./vecnorm(attach_pos - robot_pos,2,1);

%% Check Collision Condition

positive_attach_robot_vel = sum(xi.*(attach_vel - robot_vel),1) > 1e-6;
taut_condition = istaut(attach_pos,robot_pos,pl_params.cable_length);
collision_condition = positive_attach_robot_vel & taut_condition;

end