import numpy as np
import matplotlib.pyplot as plt
    
def rigid_links_test_trajectory(start = None,loadstart = None,loadstop = None,vis = None,trajhandle = None,pl_params = None,quad_params = None): 
    # TEST_TRAJECTORY simulates the robot from START to STOP following a PATH
# that's been planned for MAP.
# start - a 3d vector or a cell contains multiple 3d vectors
# stop  - a 3d vector or a cell contains multiple 3d vectors
# map   - map generated by your load_map
# path  - n x 3 matrix path planned by your dijkstra algorithm
# vis   - true for displaying visualization
    
    # # Quadrotor model
# params = snapdragonflight();
    
    # # Payload model
# pl_params = robot_team_setup(trianglepayload(),params,"Rigid Link");
    nquad = pl_params.nquad
    # ros initialization
    worldframe = 'simulator'
    payloadframe = 'payload'
    
    # cable_pub = rospublisher("/cable/marker","visualization_msgs/Marker","DataFormat","struct");
# cable_marker_scale = 0.01*ones(3);
# cable_marker_color = [1.0,1.0,0.0,0.0];
# cable_marker_msg = init_marker_msg(cable_pub,5,0,worldframe,cable_marker_scale,cable_marker_color);
    
    for i in np.arange(1,nquad+1).reshape(-1):
        robot_marker_pub[i] = rospublisher('/quadrotor' + num2str(i) + '/marker','visualization_msgs/Marker','DataFormat','struct')
        quadrotor_marker_scale = 0.5 * np.ones((3,3))
        quadrotor_marker_color = np.array([1.0,0.0,0.0,1.0])
        quadrotor_mesh = 'package://aerial_manipulation_sim/mesh/hummingbird.mesh'
        quadrotor_marker_msg[i] = init_marker_msg(robot_marker_pub[i],10,0,worldframe,quadrotor_marker_scale,quadrotor_marker_color,quadrotor_mesh)
    
    pl_odom_pub = rospublisher('/payload/marker','visualization_msgs/Marker','DataFormat','struct')
    payload_marker_scale = np.ones((3,3))
    payload_marker_color = np.array([1.0,0.745,0.812,0.941])
    system_pub = rospublisher('/system/marker','visualization_msgs/MarkerArray','DataFormat','struct')
    system_marker = rosmessage(system_pub)
    path_pub = rospublisher('/payload/path','visualization_msgs/Marker','DataFormat','struct')
    path_scale = 0.01 * np.ones((3,3))
    path_color = np.array([1.0,1.0,0.0,0.0])
    path_msg = init_marker_msg(path_pub,4,0,worldframe,path_scale,path_color)
    des_path_pub = rospublisher('/payload/des_path','visualization_msgs/Marker','DataFormat','struct')
    des_path_scale = 0.01 * np.ones((3,3))
    des_path_color = np.array([1.0,0.341,0.0235,0.549])
    des_path_msg = init_marker_msg(des_path_pub,4,0,worldframe,des_path_scale,des_path_color)
    if nquad == 1:
        controlhandle = single_payload_geometric_controller
        payload_marker_scale = np.ones((3,3)) * 0.1
        dynamicshandle = lambda t = None,s = None,pl_params = None: hybrid_ptmass_pl_transportationEOM(t,s,controlhandle,trajhandle,quad_params,pl_params)
        payload_marker_msg = init_marker_msg(pl_odom_pub,2,0,worldframe,payload_marker_scale,payload_marker_color)
    else:
        controlhandle = rigid_links_cooperative_payload_controller
        dynamicshandle = lambda t = None,s = None: rigid_links_cooperative_rigidbody_pl_EOM(t,s,nquad,controlhandle,trajhandle,quad_params,pl_params)
        payload_mesh = 'package://aerial_manipulation_sim/mesh/triangular_payload.STL'
        payload_marker_msg = init_marker_msg(pl_odom_pub,10,0,worldframe,payload_marker_scale,payload_marker_color,payload_mesh)
    
    # Make cell
    if not iscell(start) :
        start = np.array([start])
    
    ## **************************** FIGURES *****************************
# Environment figure
    if len(varargin) < 5:
        vis = True
    
    print('Initializing figures...\\n' % ())
    if vis:
        h_fig = plt.figure('Name','Environment')
    else:
        h_fig = plt.figure('Name','Environment','Visible','Off')
    
    h_3d = gca
    drawnow
    plt.xlabel('x [m]')
    plt.ylabel('y [m]')
    plt.zlabel('z [m]')
    quadcolors = lines(nquad)
    set(gcf,'Renderer','OpenGL')
    ## *********************** INITIAL CONDITIONS ***********************
    print('Setting initial conditions...\\n' % ())
    # Maximum time that the quadrotor is allowed to fly
    time_tol = 60
    
    starttime = 0
    
    tstep = 0.01
    
    cstep = 0.05
    
    nstep = cstep / tstep
    time = starttime
    
    max_iter = time_tol / cstep
    
    pl0 = np.array([[loadstart(np.arange(1,3+1))],[0],[0],[0],[loadstart(np.arange(4,7+1))],[0],[0],[0]])
    x = pl0
    # Here we just return the traj hist of the structure
    for qn in np.arange(1,1+1).reshape(-1):
        xtrajdes[qn] = []
        xtraj[qn] = []
        ttraj[qn] = []
    
    # Maximum position error of the quadrotor at goal
    pos_tol = 0.05
    
    # Maximum speed of the quadrotor at goal
    vel_tol = 0.05
    
    # state vector x (13 + 7*nquad + 6*nquad) x 1:
# x     - [xL, yL, zL, xLd, yLd, zLd,
#          [xL, yL, zL, xLd, yLd, zLd, qw, qx, qy, qz, pQuad, qQuad, rQuad]_i, i = 1,...,nquad
#pl_dim_num = 13; # rigid body
    pl_dim_num = 6
    
    quad_dim_num = 13
    ## ************************* RUN SIMULATION *************************
    print('Simulation Running....\\n' % ())
    for iter in np.arange(1,max_iter+1).reshape(-1):
        timeint = np.arange(time,time + cstep+tstep,tstep)
        tic
        # State Integration
        tsave,xsave,fsave = ode45(lambda t = None,s = None: dynamicshandle(t,s),timeint,x)
        x = np.transpose(xsave(end(),:))
        Rot = np.transpose(QuatToRot(x(np.arange(7,10+1))))
        load_pos = x(np.arange(1,3+1)) + Rot * pl_params.rho_load
        robot_pos = x(np.arange(1,3+1)) + Rot * pl_params.rho_robot
        # Update quadrotor visualization
        for qn in np.arange(1,nquad+1).reshape(-1):
            system_marker.markers[qn] = update_marker_msg(quadrotor_marker_msg[qn],robot_pos(:,qn),RotToQuat(Rot),qn)
        # Update payload visualization msg
        system_marker.markers[nquad + 1] = update_marker_msg(payload_marker_msg,load_pos,RotToQuat(Rot))
        send(system_pub,system_marker)
        # Save to traj
        for qn in np.arange(1,1+1).reshape(-1):
            xtraj[qn] = np.array([xtraj[qn],np.transpose(xsave(np.arange(1,end() - 1+1),np.arange(13 * qn - 12,13 * qn+1)))])
            ttraj[qn] = np.array([ttraj[qn],np.transpose(tsave(np.arange(1,end() - 1+1)))])
            for i in np.arange(1,len(tsave) - 1+1).reshape(-1):
                desired_state = trajhandle(tsave(i),[])
                xtrajdes[qn] = np.array([xtrajdes[qn],np.array([[desired_state.pos_des],[desired_state.vel_des],[np.transpose(desired_state.quat_des)],[np.transpose(desired_state.omega_des)]])])
        path_msg.points(iter).x = x(1)
        path_msg.points(iter).y = x(2)
        path_msg.points(iter).z = x(3)
        path_time = rostime('now')
        path_msg.header.stamp.sec = uint32(path_time.Sec)
        path_msg.header.stamp.nsec = uint32(path_time.Nsec)
        send(path_pub,path_msg)
        des_path_msg.points(iter).x = desired_state.pos_des(1)
        des_path_msg.points(iter).y = desired_state.pos_des(2)
        des_path_msg.points(iter).z = desired_state.pos_des(3)
        des_path_msg.header.stamp.sec = uint32(path_time.Sec)
        des_path_msg.header.stamp.nsec = uint32(path_time.Nsec)
        send(des_path_pub,des_path_msg)
        # Update simulation time
        time = time + cstep
        t = toc
        # Pause to make real-time
        if (t < cstep):
            #fprintf('t is smaller than cstep\n')
            pause(cstep - t)
        # Check termination criteria
        terminate_cond = terminate_check(x,time,loadstop,pos_tol,vel_tol,time_tol)
        if terminate_cond:
            break
    
    print('Simulation Finished....\\n' % ())
    return xtraj,xtrajdes,ttraj,terminate_cond
    
    return xtraj,xtrajdes,ttraj,terminate_cond