import numpy as np
import matplotlib.pyplot as plt
    
def hybrid_test_trajectory(start = None,loadstart = None,loadstop = None,vis = None,trajhandle = None,pl_params = None,quad_params = None): 
    # TEST_TRAJECTORY simulates the robot from START to STOP following a PATH
# that's been planned for MAP.
# start - a 3d vector or a cell contains multiple 3d vectors
# stop  - a 3d vector or a cell contains multiple 3d vectors
# map   - map generated by your load_map
# path  - n x 3 matrix path planned by your dijkstra algorithm
# vis   - true for displaying visualization
    
    # Get nquad
    nquad = len(start)
    ## ************************ ROS Initialization **************************
    worldframe = 'simulator'
    payloadframe = 'payload'
    cable_pub = rospublisher('/cable/marker','visualization_msgs/Marker','DataFormat','struct')
    cable_marker_scale = 0.01 * np.ones((3,3))
    cable_marker_color = np.array([1.0,0.5,0.5,0.5])
    cable_marker_msg = init_marker_msg(cable_pub,5,0,worldframe,cable_marker_scale,cable_marker_color)
    for i in np.arange(1,nquad+1).reshape(-1):
        robot_marker_pub[i] = rospublisher('/quadrotor' + num2str(i) + '/marker','visualization_msgs/Marker','DataFormat','struct')
        quadrotor_marker_scale = 0.5 * np.ones((3,3))
        quadrotor_marker_color = np.array([1.0,0.0,0.0,1.0])
        quadrotor_mesh = 'package://mesh_visualization/mesh/hummingbird.mesh'
        quadrotor_marker_msg[i] = init_marker_msg(robot_marker_pub[i],10,0,worldframe,quadrotor_marker_scale,quadrotor_marker_color,quadrotor_mesh)
    
    pl_odom_pub = rospublisher('/payload/marker','visualization_msgs/Marker','DataFormat','struct')
    payload_marker_scale = np.ones((3,3))
    payload_marker_color = np.array([1.0,0.745,0.812,0.941])
    system_pub = rospublisher('/system/marker','visualization_msgs/MarkerArray','DataFormat','struct')
    system_marker = rosmessage(system_pub)
    path_pub = rospublisher('/payload/path','visualization_msgs/Marker','DataFormat','struct')
    path_scale = 0.01 * np.ones((3,3))
    path_color = np.array([1.0,1.0,0.0,0.0])
    path_msg = init_marker_msg(path_pub,4,0,worldframe,path_scale,path_color)
    des_path_pub = rospublisher('/payload/des_path','visualization_msgs/Marker','DataFormat','struct')
    des_path_scale = 0.01 * np.ones((3,3))
    des_path_color = np.array([1.0,0.341,0.0235,0.549])
    des_path_msg = init_marker_msg(des_path_pub,4,0,worldframe,des_path_scale,des_path_color)
    #Controller and trajectory generator handles
    
    if nquad == 1:
        controlhandle = single_payload_geometric_controller
        payload_marker_scale = np.ones((3,3)) * 0.1
        dynamicshandle = lambda t = None,s = None,pl_params = None: hybrid_ptmass_pl_transportationEOM(t,s,controlhandle,trajhandle,quad_params,pl_params)
        payload_marker_msg = init_marker_msg(pl_odom_pub,2,0,worldframe,payload_marker_scale,payload_marker_color)
    else:
        quadattcontrolhandle = cooperative_attitude_controller
        plcontrolhandle = cooperative_payload_controller
        dynamicshandle = lambda t = None,s = None: cooperative_suspended_pl_transportationEOM(t,s,nquad,plcontrolhandle,quadattcontrolhandle,trajhandle,quad_params,pl_params)
        payload_mesh = 'package://mesh_visualization/mesh/triangular_payload.STL'
        payload_marker_msg = init_marker_msg(pl_odom_pub,10,0,worldframe,payload_marker_scale,payload_marker_color,payload_mesh)
    
    # Make cell
    if not iscell(start) :
        start = np.array([start])
    
    # Make column vector
    for qn in np.arange(1,nquad+1).reshape(-1):
        start[qn] = start[qn]
    
    ## **************************** FIGURES *****************************
# Environment figure
    if len(varargin) < 5:
        vis = True
    
    print('Initializing figures...\\n' % ())
    if vis:
        h_fig = plt.figure('Name','Environment')
    else:
        h_fig = plt.figure('Name','Environment','Visible','Off')
    
    h_3d = gca
    drawnow
    plt.xlabel('x [m]')
    plt.ylabel('y [m]')
    plt.zlabel('z [m]')
    quadcolors = lines(nquad)
    set(gcf,'Renderer','OpenGL')
    ## *********************** INITIAL CONDITIONS ***********************
    print('Setting initial conditions...\\n' % ())
    # Maximum time that the quadrotor is allowed to fly
    time_tol = 60
    
    starttime = 0
    
    tstep = 0.01
    
    cstep = 0.05
    
    nstep = cstep / tstep
    time = starttime
    
    max_iter = time_tol / cstep
    
    for qn in np.arange(1,nquad+1).reshape(-1):
        x0[qn] = init_state(start[qn],0)
    
    x = np.array([[loadstart(np.arange(1,3+1))],[0],[0],[0],[start[0]],[0],[0],[0],[x0[qn](np.arange(7,end()+1))]])
    
    xtraj[0] = []
    ttraj[0] = []
    xtrajdes[0] = []
    # Maximum position error of the quadrotor at goal
    pos_tol = 0.05
    
    # Maximum speed of the quadrotor at goal
    vel_tol = 0.05
    
    quad_state = x0
    #pl_dim_num = 13; # rigid body
    pl_dim_num = 6
    
    quad_dim_num = 13
    global cable_is_slack
    cable_is_slack = not istaut(x(np.arange(1,3+1)),x(np.arange(7,9+1)),pl_params.cable_length) 
    ## ************************* RUN SIMULATION *************************
    print('Simulation Running....\\n' % ())
    for iter in np.arange(1,max_iter+1).reshape(-1):
        timeint = np.arange(time,time + cstep+tstep,tstep)
        tic
        # Inelastic collision
        pl_pos = x(np.arange(1,3+1))
        pl_vel = x(np.arange(4,6+1))
        robot_pos = x(np.arange(7,9+1))
        robot_vel = x(np.arange(10,12+1))
        cable_norm_vel = np.transpose((pl_pos - robot_pos)) * (pl_vel - robot_vel)
        if cable_norm_vel > 1e-06 and not cable_is_slack :
            x[np.arange[4,6+1]],x[np.arange[10,12+1]] = ptmass_inelastic_cable_collision(x(np.arange(1,6+1)),x(np.arange(7,12+1)),pl_params.mass,quad_params.mass)
        # Simulate Dynamics
        if cable_is_slack:
            # The integration stops when the distance between robot and payload
# equals to the cable length
            option = odeset('Events',lambda t = None,x = None: slackToTaut(t,x,pl_params.cable_length))
            tsave,xsave,fsave = ode45(lambda t = None,s = None: dynamicshandle(t,s,pl_params),timeint,x,option)
        else:
            option = odeset('Events',lambda t = None,x = None: tautToSlack(t,x,pl_params.cable_length))
            tsave,xsave,fsave = ode45(lambda t = None,s = None: dynamicshandle(t,s,pl_params),timeint,x,option)
        x = np.transpose(xsave(end(),:))
        cable_is_slack = not istaut(np.transpose(xsave(end(),np.arange(1,3+1))),np.transpose(xsave(end(),np.arange(7,9+1))),pl_params.cable_length) 
        # Save to traj
        xtraj[0] = np.array([xtraj[0],np.transpose(xsave(np.arange(1,end() - 1+1),:))])
        ttraj[0] = np.array([ttraj[0],np.transpose(tsave(np.arange(1,end() - 1+1)))])
        for i in np.arange(1,len(tsave) - 1+1).reshape(-1):
            desired_state = trajhandle(tsave(i),[])
            xtrajdes[0] = np.array([xtrajdes[0],np.array([[desired_state.pos_des],[desired_state.vel_des]])])
        # Update payload plot
        desired_state = trajhandle(time + cstep,[])
        payload_state = x(np.arange(1,pl_dim_num+1))
        quad_state[0] = x(np.arange(pl_dim_num + 1,end()+1))
        # Update payload path
        path_msg.points(iter).x = payload_state(1)
        path_msg.points(iter).y = payload_state(2)
        path_msg.points(iter).z = payload_state(3)
        path_time = rostime('now')
        path_msg.header.stamp.sec = uint32(path_time.Sec)
        path_msg.header.stamp.nsec = uint32(path_time.Nsec)
        send(path_pub,path_msg)
        # Update payload desired path
        des_path_msg.points(iter).x = desired_state.pos_des(1)
        des_path_msg.points(iter).y = desired_state.pos_des(2)
        des_path_msg.points(iter).z = desired_state.pos_des(3)
        des_path_msg.header.stamp.sec = uint32(path_time.Sec)
        des_path_msg.header.stamp.nsec = uint32(path_time.Nsec)
        send(des_path_pub,des_path_msg)
        # Update quadrotor visualization
        system_marker.markers[qn] = update_marker_msg(quadrotor_marker_msg[qn],quad_state[qn](np.arange(1,3+1)),RotToQuat(np.transpose(QuatToRot(quad_state[qn](np.arange(7,10+1))))),qn)
        # Update cable visualization
        cable_point_list = np.array([payload_state(np.arange(1,3+1)),quad_state[0](np.arange(1,3+1))])
        system_marker.markers[2] = update_line_list_msg(cable_marker_msg,cable_point_list,2)
        # Update payload visualization
        system_marker.markers[3] = update_marker_msg(payload_marker_msg,payload_state(np.arange(1,3+1)),np.array([[1],[0],[0],[0]]),0)
        # Publish the marker message
        send(system_pub,system_marker)
        # Update simulation time
        time = time + tsave(end()) - tsave(1)
        t = toc
        # Pause to make real-time
        if (t < cstep):
            #fprintf('t is smaller than cstep\n')
            pause(cstep - t)
        # Check termination criteria
        terminate_cond = terminate_check(x,time,loadstop,pos_tol,vel_tol,time_tol)
        if terminate_cond:
            break
    
    print('Simulation Finished....\\n' % ())
    return xtraj,xtrajdes,ttraj,terminate_cond
    
    return xtraj,xtrajdes,ttraj,terminate_cond